/** * @class FR.WritePane * @class */$.extend(FR.WritePane.prototype, function () {    var P = {        /*         * alex:初始化ContentPane         */        initContentPane: function () {            this.currentSessionID = "";            this.isWriteOfflinePage = true;            if (this.options["writeCss"]) {                $.each(this.options["writeCss"], function (i, item) {                    FR.$import(item, 'css');                });            }            var tabPane = this.$contentPane.data("TabPane");            var self = this;            if (tabPane) {//james：TabPane                tabPane.on(FR.Events.TABCHANGESTART, function () {                    if (self.curLGP) {                        self.stopEditing();                        if ($('div.verify-error-info:visible', FR.$view_container).length > 0) {                            $('div.verify-error-info:visible', FR.$view_container).hide();                        }                    }                });                //james：给TabPane绑定tabchange事件                tabPane.on(FR.Events.TABCHANGE, function (tabPane, tabIndex) {                    self.selectedIndex = tabIndex;                    self.fireEvent(FR.Events.TABCHANGE, tabPane, tabIndex);                });                //james：给当前的FormPane绑定tabchange事件，这个是真正的执行tabchange的内容                this.on(FR.Events.TABCHANGE, function (tabPane, tabIndex) {                    if (self.delay) {                        return;                    }                    self.selectedIndex = tabIndex;                    var lgp = self.lgps[tabIndex];                    if (lgp.loaded === false) {                        lgp.loadLGPPane();                    } else {                        // Carl：这个怎么能不变                        self.curLGP = lgp;                        self.curLGP._selectFirstTD();                        self.curLGP.onfocus();                        if (!lgp.frozenModified && $('.frozen-center', lgp.$container).length > 0) {                            if (lgp.$sheet_container.parent().isVisible()) {                                FR.layoutFrozen(lgp.$sheet_container, lgp.$sheet_container.offset().top);                                lgp.frozenModified = true;                            }                        }                    }//                    self.selectedIndex = lgp.idx;                    // 填报分页,把目标sheet的页码信息传递给writePane,fire(afterload)为了更新工具栏的页码                    if (self.options["cutpage"] == 'v' || self.options["cutpage"] == 'w') {                        self.currentPageIndex = lgp.currentPageIndex;                        self.reportTotalPage = lgp.reportTotalPage;                        self.fireEvent(FR.Events.AFTERLOAD);                    }                });                var tabs = tabPane.options.tabs;//james：获取tabs的个数                this.lgps = [];                for (var i = 0, count = tabs.length; i < count; i++) {                    this.lgps[i] = new FR.WLGP({                        idx: i,                        $container: $(tabs[i].content),                        writePane: this,                        selectMethod: this.selectMethod                    });                }            } else {                this.lgps = [new FR.WLGP({                    idx: 0,                    $container: this.$contentPane,                    writePane: this,                    selectMethod: this.selectMethod                })];            }            // todo 页面信息            for (var key in FR.WE.config) {                if (key == "lgps") {                    continue;                }                this[key+""] = FR.WE.config[key+""];            }            FR.requestURL = FR.WE.config.requestURL;            // 给各个sheet添加报表结构信息 以及用本地存储的离线数据更新resultCells            for (var i=0; i<this.lgps.length; i++) {                // 固定配置                this.lgps[i].refreshDataOnInit();                // 本地数据                this.lgps[i].refreshDataByLocal();            }            this.processNote = FR.WE.getProcessNote() || [];            if (this.options['selectedColor']) {                var color = '.test{background-color:' + this.options['selectedColor'] + '!important}';                $('<style type="text/css">' + color + '</style>').appendTo('head');            }            // 初始化粘贴功能            $("body").append("<div style='position:absolute;left:-1000px;top:-1000px;'>" +                "<textarea id='cpTextArea' onkeyup='this.blur()'></textarea></div>");            /**             * 页面转向时提示,不支持opera             */            window.onbeforeunload = this.beforeUnloadCheck.createDelegate(this);            // 防止backspace跳转.            $(document)[($.browser.mozilla || $.browser.opera)                ? 'keypress'                : 'keydown'](function (e) {                self.banBackSpace(e);            });        },        /**         * 离线填报的提交 需要把当前的配置信息和数据送到后台去匹配         * 得到sessionID 再执行校验和入库的操作  todo         */        verifyAndWriteReport: function (isAllSheet, submitButton, successFn) {            var self = this;            var o = {                overlay_immediately: true,                text: FR.i18nText('Calculating') + "...."            };            FR.showLoadingDialog(o);            if (submitButton) {                submitButton.disable();            }            this.stopEditing();            // 用jsonp解决ajax请求数据的跨域问题//            if (this.currentSessionID) {//                // 初始化的时候清除currentSessionID//                // 提交的时候到后台申请了个id过来 就不用继续申请了//                // a提交过的得到了sessionid万一这时候服务器断开了就会出问题了//                this.importReportData(isAllSheet, submitButton, successFn);//            } else {                this.registerReportSession({fn: function() {                    self.importReportData(isAllSheet, submitButton, successFn);                }, errorFn: function() {                    FR.hideLoadingDialog();                    submitButton && submitButton.enable();                    FR.Msg.alert(FR.i18nText("Failed"), FR.i18nText('Offline-Connect_Failed'));                }, submitButton: submitButton});//            }        },        /**         * 注册模板session 获取sessionID 并执行相应方法         * options.fn：正确回调         * options.errorFn：错误回调         * @param options         */        registerReportSession: function(options) {            if (!options) {                return;            }            var self = this;            var success = false;            var defaultError = function() {                FR.hideLoadingDialog();                FR.Msg.alert(FR.i18nText("Failed"), FR.i18nText('Offline-Connect_Failed'));                options.submitButton &&  options.submitButton.enable();            };            FR.ajax({                url: FR.requestURL,                type: 'GET',                async: false,                dataType : "jsonp",                jsonp: "callbackparam",                jsonpCallback:"success_jsonpCallback",                data: {                    op: "write",                    reportlet: self.reportlet,                    isWriteOfflinePage: true                },                success: function(res) {                    success = true;                    if (res && res.sessionID) {                        self.currentSessionID = res.sessionID;                        if (options.fn) {                            options.fn();                        }                    }                },                error: function(res) {                    if (options.errorFn) {                        options.errorFn();                    } else {                        defaultError();                    }                }            });            // jsonp同步不了            // 不知道为什么无法连接上的时候success和error都不执行了，complete也不执行了            setTimeout(function() {                if (!success) {                    defaultError();                }            }, 3000);        },        /**         * 先发送离线数据         */        importReportData: function(isAllSheet, submitButton, successFn) {            var self = this;            var config = [];            for (var i=0; i<this.lgps.length; i++) {                var cc = {};                var lg = this.lgps[i];                $.each(["resultCells", "colArray", "rowArray"], function(idx, item) {                    cc[item] = lg[item];                });                cc["insertRowArr"] = lg.oriInsRowArr.concat(lg.insertRowArr);                config.push(cc);            }            var params = {                op: "fr_off_write",                cmd: "write_offline_import",                config: FR.jsonEncode(config)            };            doSave.call(this, {params: params, fn: function (res) {                // 完成后进行校验                if (res && res["status"] != "success") {                    FR.Msg.toast(res["status"]);                    return false;                }                if (self.fireEvent(FR.Events.BVW, self) === false) {                    return false;                }                self.preventNoVerifier = true;                var verify = function () {                    self._doVerify(                        self.writeReport.createDelegate(self, [(isAllSheet ? null : self.selectedIndex),                            submitButton ? submitButton : null, successFn]),                        function (resultJSON) {                            self.popup_error(resultJSON, submitButton);                            submitButton && submitButton.enable();                        },                        isAllSheet ? null : self.selectedIndex, (submitButton ? submitButton : undefined));                };                setTimeout(verify, 10);            }, errorFn: function() {                FR.Msg.toast("error on import data");                submitButton && submitButton.enable();                FR.hideLoadingDialog();            }});        },        // TODO 关联格子的计算        /**         * shoc 离线的web端再计算         * @param sheetIdx         * @param location         * @param cellValue         */        writeDirtyAndRemoteCal: function (sheetIdx, location, cellValue) {            if (location == null) {                return;            }            var self = this;            var obj, cr, idx, oriCE, ceArr = {};            // 计算前先把相关的格子的calculated置位            // 收集所有基于此格子的格子            collectDeps(sheetIdx, location);            function collectDeps(sheetIdx, location) {                var depsArr = self.lgps[sheetIdx].whoDependOn[location];                if (depsArr == null || !$.isArray(depsArr)) {                    return;                }                for (var i=0; i<depsArr.length; i++) {                    obj = depsArr[i].split('-');                    cr = obj[0];                    idx = obj[1];                    oriCE = self.lgps[idx].getCEFrom(cr);                    if (!ceArr[cr]) {                        ceArr[cr] = {                            ce_from: oriCE,                            calculated: false,                            idx: idx                        };                        collectDeps(idx, cr);                    }                }            }            try {                for (cr in ceArr) {                    this.calculateCertainCell(sheetIdx, ceArr, cr);                }            } catch(e) {            } finally {                for (cr in ceArr) {                    delete ceArr[cr].calculated;                    delete ceArr[cr].isCalculating;                }            }        },        calculateCertainCell: function(sheetIdx, ceArr, cr) {            var self = this;            var ce = ceArr[cr];            if (ce == null) {                return;            }            if (ce.calculated) {                return;            }            if (ce.isCalculating) {                FR.Msg.toast("Death Circle At " + cr);                return;            }            ce.isCalculating = true;            var oriCE = ce.ce_from;            var sheetIndex = ce.idx == null ? sheetIdx : ce.idx;            var curSheet = self.lgps[sheetIndex];            var columnRow = FR.cellStr2ColumnRow(cr);            var oriColumnRow = FR.cellStr2ColumnRow(oriCE.cr);            var formula = oriCE.formula;            // 如果这个格子依赖于另外的需要重计算而没有重计算的格子 那么先计算后者            var relatedCRs = FR.WE.getRelatedColumnRow(formula);            for (var j=0; j<relatedCRs.length; j++) {                // a这个地方应该本身就是指的扩展前                var relateCE = self.lgps[sheetIndex].getCE(relatedCRs[j]);                if (relateCE == null || ceArr[relatedCRs[j]] == null) {                    continue;                } else if (relateCE.calculated === false) {                    self.calculateCertainCell(sheetIdx, ceArr, relatedCRs[j]);                }            }            // 下面就开始计算了            var cellsForCal = curSheet.collectRelatedCellValues(columnRow, relatedCRs);            var calConfig = {                lgp: curSheet,                relatedCells: cellsForCal,                currentCell: columnRow,                parameters: $.extend({}, self.parameters, {                    $$$: curSheet.getCellValue(columnRow.col, columnRow.row)                })            };            var result = new FR.CAL(calConfig).eval(formula);            // 是不支持的公式要特别对待            if (result == FR.WE.ERROR_NOT_SUPPORT) {                self.setCellValueWithoutHistory(sheetIndex, columnRow.col, columnRow.row, "");                var cell = this.lgps[sheetIndex]._get$TDCell(columnRow.col, columnRow.row);                this.lgps[sheetIndex].makeNotSupportError(cell);            } else {                // 关联格子值的改变也要记录到本地 在fireCellValueChange中进行的                // writePane的setCellValue才会触发fireCellValueChange                self.setCellValueWithoutHistory(sheetIndex, columnRow.col, columnRow.row, result);            }            ce.calculated = true;            delete ce.isCalculating;        },        /**         * 这个方法的功能是         * 设置格子值 触发格子值改变事件 触发关联格子计算 保存值到本地         * 但是不添加历史 因为一次操作可能会触发多次设置值 只要一次历史         * @param o         */        setCellValueWithoutHistory: function (o) {            var config = {};            if (arguments.length === 3) {                config.columnIndex = arguments[0];                config.rowIndex = arguments[1];                config.value = arguments[2];                config.reportIndex = this.selectedIndex;            } else if (arguments.length === 4) {                config.reportIndex = arguments[0];                config.columnIndex = arguments[1];                config.rowIndex = arguments[2];                config.value = arguments[3];            } else {                config = o;            }            var lp = this.lgps[config.reportIndex];            if (lp) {                if (lp.loaded === false) {                    lp.loadLGPPane(false);                }                lp.setCellValue(config.columnIndex, config.rowIndex, config.value);                lp.fireCellValueChange(lp.getTDCell(config.columnIndex, config.rowIndex), config.value, null, false);            }        },        reCalCurLGPPane: function() {            if (this.lgps == null || this.curLGP == null) {                return;            }            this.curLGP.recalculate();        },        refreshAllSheets: function() {            if (this.lgps == null) {                return;            }            for (var i=0; i<this.lgps.length; i++) {                this.lgps[i].recalculate();            }        },        writeReport: function (reportIndex, submitButton, successFn) {            if (this.fireEvent(FR.Events.BW, this) === false) {                return false;            }            var self = this;            var params = {op: "fr_off_write", cmd: "write_offline_submit"};            if (reportIndex != null) {                params = $.extend(params, {reportIndex: reportIndex})            }            doSave.call(this, {params: params, fn: function (res) {                var submitInfo = {};                var json_array = res;                if (json_array.length > 0) {                    $.each(json_array, function (idx, item) {                        if (item.fr_submitinfo) {                            submitInfo = item.fr_submitinfo;                        }                    });                }                if (submitButton) {                    // bug26782                    setTimeout(function () {                        submitButton.enable();                    }, 10);                }                if (self.fireEvent(FR.Events.AVW, self, submitInfo) === false) {                    return;                }                if (self.fireEvent(FR.Events.AW, submitInfo) === false) {                    return;                }                var success = submitInfo.success;                if (success !== true && success !== false) {                    if (!self.preventNoWriter) {                        // carl:这里表示没有填报属性设置，提示用户即可                        FR.Msg.toast(FR.i18nText("Report") + FR.i18nText("Report-Write_Attributes_Msg"));                    } else {                        successFn && successFn();                        delete self.preventNoWriter;                    }                } else if (success === true) {                    FR.Msg.toast(FR.i18nText("Successfully"));                    self.fireEvent(FR.Events.WS);                    successFn && successFn();                } else if (success === false) {                    FR.Msg.toast(FR.i18nText("Failed"));                    self.fireEvent(FR.Events.WF);                }            }});        },        /*         * fn是保存之后的callback         */        saveReport: function (fn) {//            doSave.call(this, {fn: fn || function (res) {//                FR.Msg.toast(res.responseText);//            }})        },        // TODO 离线校验        /**         * 这个是离线的校验         */        verifyReport: function () {            var verifyButton = this.verifyButton = arguments[0];            var successFn = function() {                FR.Msg.toast(FR.i18nText('Verify-Verify_Success'));                verifyButton && verifyButton.enable();            }            var self = this;            var failFn = function(resultJSON) {                 self.popup_error(resultJSON, verifyButton)                 verifyButton && verifyButton.enable();            }            // 改校验按钮执行的verifyReport，            // _doVerify还要留给联网提交的时候进行的校验            this.stopEditing();            this.remove_error();            var resultJSON = [];            this.validateWidgets(resultJSON, true);            // 先遍历校验规则看看有没有不支持的公式 或者自定义类校验            var notSupport = false;            sdf: for (var idx=0; idx<this.lgps.length; idx++) {                if (this.lgps[idx].verify) {                    for (var i=0; i<this.lgps[idx].verify.length; i++) {                        var curVerify = this.lgps[idx].verify[i];                        if (curVerify.UNSUPPORT) {                            notSupport = true;                            break sdf;                        }                        var formula = curVerify.formula;                        var fns = FR.WE.getFunctionNames(formula);                        for (var ii=0; ii<fns.length; ii++) {                            if (FR.FUN[fns[ii].toUpperCase()] == null) {                                notSupport = true;                                break sdf;                            }                        }                    }                }            }            if (notSupport) {                FR.Msg.alert(FR.i18nText('Tooltips'), FR.i18nText('Offline-Verify_ToolTips'), function(result) {                    if (result) {                        verify();                    }                })            } else {                verify();            }            function verify() {                for (var idx=0; idx<self.lgps.length; idx++) {                    if (self.lgps[idx].verify) {                        for (var i=0; i<self.lgps[idx].verify.length; i++) {                            var curVerify = self.lgps[idx].verify[i];                            if (curVerify.UNSUPPORT) {                                continue;                            }                            var formula = curVerify.formula;                            var relatedCRs = FR.WE.getRelatedColumnRow(formula);                            var valueGroup = self.lgps[idx].getCellValueGroup(relatedCRs);                            for (var j=0; j<valueGroup.length; j++) {                                var baseCells = {};                                for (var k=0; k<relatedCRs.length; k++) {                                    baseCells[relatedCRs[k]] = valueGroup[j][k];                                }                                var config = {                                    relatedCells: baseCells,                                    parameters: self.parameters                                }                                var checkResult = new FR.CAL(config).eval(formula);                                // 结果为false 则出错 要push信息到resultJSON                                if (checkResult === false) {                                    var currentCRs = [];                                    for (k=0; k<relatedCRs.length; k++) {                                        currentCRs.push(self.lgps[idx].getExpandColumnRowStr(relatedCRs[k], j));                                    }                                    var error = {                                        columnrows: currentCRs,                                        message: curVerify.message,                                        reportIndex: idx                                    }                                    resultJSON.push(error);                                }                            }                        }                    }                }                if (resultJSON.length > 0) {                    failFn(resultJSON);                } else {                    successFn();                }            }        },        /**         * 离线填报在和服务器建立连接时候用的校验         */        _doVerify: function (successFn, failureFn, reportIndex) {//私有方法            // 要先stop editing            this.stopEditing();            // shoc:verify前先移除全部  bug28182            this.remove_error(reportIndex);            var resultJSON = [];            var self = this;            var params = {op: "fr_off_write", cmd: "write_offline_verify"};            // richer:是否需要调用Widget的invalidate()方法来进行校验？            // james：先校验整个报表中是不是有不允许为空，但没有cv值的格子            if (reportIndex != null) {                this.validateWidgets(resultJSON);                params = $.extend(params, {reportIndex: reportIndex});            } else {                this.validateWidgets(resultJSON, true);            }            doSave.call(this, {params: params, fn: function (res) {                var verifyInfo = {};                var json_array = res;                if (json_array.length > 0) {                    $.each(json_array, function (idx, item) {                        // 下面这个push的reportIndex全都是当前sheet的 不对 放在后台添加                        //item.reportIndex = self.curLGP.idx;                        if (item.fr_verifyinfo) {                            verifyInfo = item.fr_verifyinfo;                        } else {                            resultJSON.push(item);                        }                    });                }                if (self.fireEvent(FR.Events.AV, verifyInfo) === false) {                    if (self.verifyButton) {                        self.verifyButton.enable();                    }                    return;                }                if (resultJSON.length > 0) {                    $.isFunction(failureFn) && failureFn(resultJSON);                } else {                    if (verifyInfo.success === true || self.preventNoVerifier === true) {                        $('div.verify-error-container', FR.$view_container).remove();                        $('div.verify-error-number').remove();                        $.isFunction(successFn) && successFn();                    } else {                        // 没有设置校验属性 或者 找不到自定义类的情况                        // 填报时候带的校验不显示这个东西 只有单纯的数据校验才显示                        FR.Msg.toast(verifyInfo.info);                        self.verifyButton && self.verifyButton.enable();                    }                }                delete self.preventNoVerifier;            }});        },        // 清空        clear: function() {            this._dealOperate(arguments[0], 0);        },        // 撤销        undo: function() {            this._dealOperate(arguments[0], 1);        },        // 重做        redo: function() {            this._dealOperate(arguments[0], 2);        },        _dealOperate: function(btn, t) {            btn && btn.disable();            try {                if (t === 0) {                    FR.WE.localData.clearLocalData();                } else if (t === 1) {                    FR.WE.localData.undo();                } else if (t === 2) {                    FR.WE.localData.redo();                }                this.curLGP.refreshDataOnInit();                this.curLGP.refreshDataByLocal();                this.reloadCurLGPPane();            } catch(e) {            } finally {                btn && btn.enable();            }            this._checkBtnState();        },        _checkBtnState: function() {            this.undoBtn && this.undoBtn.setEnable(FR.WE.localData.hasBeforeHistory());            this.redoBtn && this.redoBtn.setEnable(FR.WE.localData.hasAfterHistory());        },        addHistory: function() {            FR.WE.localData.addHistory();            this._checkBtnState();        },        offlineSave: function(options) {            var self = this;            if (this.currentSessionID) {                doSave.call(this, options, false);            } else {                this.registerReportSession({                    fn: function() {                        doSave.call(self, options, false);                    }                });            }        }    }    /*     * TODO shoc 离线的 按钮插入删除行     */    $.each(['append', 'delete', 'undelete'], function (idx, it) {        /*         * appendReportRow appendReportColumn deleteReportRow deleteReportColumn         */        P[it + 'ReportRow'] = function () {            if (this.fireEvent('before' + it) === false) {                return;            }            this.stopEditing();            // 插入新行前注销点击事件            this.curLGP.unfocus();            var location = FR.id2Location(arguments[0]);            if (location == null) {                return;            }            var btnCRStr = FR.columnRow2CellStr(location);            var btnTD = $(this.curLGP.getTDCell(location.col, location.row));            var fixCount = parseInt(btnTD.attr('fixCount')); // 插入行数            var fixCR = this.curLGP.getFixCR(location);            var fixTd = $(this.curLGP.getTDCell(fixCR.col, fixCR.row));            var fixSpan = parseInt(fixTd.attr('rowspan')) || 1;            if (it == 'append') {                var tmpCells = {};                this.curLGP.appendRowOnStructure(false, fixCR, fixCount, tmpCells);                this.curLGP.appendRowOnData(false, fixCR, fixCount, fixSpan, btnCRStr, tmpCells);            } else {                this.curLGP.deleteRowOnStructure(false, fixCR);                this.curLGP.deleteRowOnData(false, fixCR, btnCRStr);            }            this.curLGP.recalculate();            this.addHistory();            this.fireEvent('after' + it);        }    });    $.each(['append', 'delete'], function (idx, it) {        /*         * appendReportRC deleteReportRC         */        P[it + 'ReportRC'] = function () {            // arguments: count(append)1            if (this.fireEvent('before' + it) === false) {                return;            }            this.stopEditing();            var count = arguments[0] || 1;            // 目标格子            var targetCells = arguments[1];            if (!targetCells) {                targetCells = $(this.curLGP.currentTDCell).attr("id");            }            if ($.isArray(targetCells)) {            } else {                var fixCR = targetCells ? FR.id2Location(targetCells) : null;                if (fixCR == null) {                    FR.Msg.toast(FR.i18nText('Invalid_Cell'));                    return;                }                // 插入记录 不管是否是合并格子都只是增加一行并有完整的td                // 不同于按钮插入行 插入记录copy的行总是焦点所在块的最后一个tr                var locStr = FR.columnRow2CellStr(fixCR);                var fixTd = $(this.curLGP.getTDCell(fixCR.col, fixCR.row));                var fixSpan = parseInt(fixTd.attr('rowspan')) || 1;                if (it == 'append') {                    var tmpCells = {};                    this.curLGP.appendRowOnStructure(true, fixCR, count, tmpCells);                    this.curLGP.appendRowOnData(true, fixCR, count, fixSpan, locStr, tmpCells);                } else {                    this.curLGP.deleteRowOnStructure(true, fixCR);                    this.curLGP.deleteRowOnData(true, fixCR, locStr);                }            }            this.curLGP.recalculate();            this.addHistory();            this.fireEvent('after' + it);        }    });    /**     * 用jsonp取得session后调用的     *     * jsonp只能以get方式提交 而get有长度限制     * 同源iframe方式的话基础域名必须相同 也不行     *     * @param options     * @param sendXML     */    function doSave(options, sendXML) {        this.stopEditing();        var self = this;        // jsonp方式//        FR.ajax({//            url: FR.requestURL,//            type: 'GET',//            async: false,//            dataType : "jsonp",//            jsonp: "callbackparam",//            jsonpCallback:"success_jsonpCallback",//            data: $.extend({//                op: "fr_write",//                cmd: "save_w_content",//                sessionID: this.currentSessionID,//                reportXML: this.generateReportXML(true),//                cutPage: this.options.cutpage//            }, options.params),//            success: (options.fn || FR.emptyFn).createSequence(FR.hideLoadingDialog)//        });        // iframe方式//        $('#fr_proxy').remove();//        var $p = $('<iframe src="" id="fr_proxy" style="display:none;" onload="loadData()"/>');//        $p.attr('src', this.requestURL + '?reportlet=' + this.reportlet + '&isOfflineProxyPage=true');//        $p.appendTo($('body'));//        document.domain = "xxx.com";//        function loadData() {//            $p[0].contentWindow.FR.ajax({//                type: "POST",//                url: FR.requestURL,//                data:$.extend({//                    op: "fr_write",//                    cmd: "save_w_content",//                    sessionID: this.currentSessionID,//                    reportXML: this.generateReportXML(true),//                    cutPage: this.options.cutpage//                }, options.params),//                async: false,//                dataType: 'json',//                success: (options.fn || FR.emptyFn).createSequence(FR.hideLoadingDialog)//            });//        }        // 数据切割        var limit = 200 - FR.requestURL.length;        var data = $.extend({            op: "fr_off_write",            cmd: "save_w_content",            sessionID: this.currentSessionID,            cutPage: this.options.cutpage        }, options.params);        if (sendXML !== false) {            data.reportXML = this.generateReportXML(true);            data.parameters = getParameters();        }        data = FR.cjkEncodeDO(data);        var data_bak = $.extend({}, data);        delete data_bak.sessionID;        delete data_bak.op;        delete data_bak.cmd;        var str = FR.jsonEncode(data_bak);        var count = Math.ceil(str.length / limit);        var idx = 0;        sendData();        function sendData() {            var sub = str.substring(idx * limit, (idx + 1) * limit);            var fun = FR.emptyFn;            var dData = {                sessionID: self.currentSessionID,                op: data.op,                cmd: data.cmd,                dataClip: sub            };            if (idx === count - 1) {                dData.f_end = 1;                fun = (options.fn || FR.emptyFn).createSequence(FR.hideLoadingDialog);            }            FR.ajax({                url: FR.requestURL,                type: 'GET',                async: false,                dataType : "jsonp",                jsonp: "callbackparam",                jsonpCallback:"success_jsonpCallback",                data: dData,                success: function(res) {                    fun(res);                    if (idx < count - 1) {                        idx ++;                        sendData();                    }                },                error: function(res) {                    if (options.errorFn) {                        options.errorFn();                    } else {                        FR.Msg.toast("error");                        FR.hideLoadingDialog();                    }                }            });        }        function getParameters() {            var paras = {};            var skip = [                "OP", "CMD", "REPORTLET", "REPORTNAME", "SESSIONID", "__LOCALE__"            ];            for (var pname in contentPane.parameters) {                if ($.inArray(pname, skip) === -1) {                    paras[pname] = contentPane.parameters[pname];                }            }            return paras;        }    }    return P;}());$.extend(FR.WLGP.prototype, function () {    return {        /**         * 需要些信息来实现离线的校验、wed端再计算等         * 需要记录到本地的东西有 rowArray,deletedRowArr,insertRowArr(有插入删除行操作情况下)         *                      resultCells 记录改变的         */        // column row 的扩展开的信息 [0,1,1,1,2,2]        colArray : null,        rowArray : null,        // 插入行    操作序号-插入行数-插入点-插入类型        // 插入类型：0-按钮插入行  1-按钮删除行   3-工具栏插入记录   4-工具栏删除记录        oriInsRowArr: null,        insertRowArr: null,        // dependence        dependOnWho : null,        whoDependOn : null,        // cells 扩展前的 包含 值 公式 父子格 显示值 插入行策略 控件等 静态的        baseCells : null,        // 扩展后的 结果报表的格子值 只记录部分的 "A1":"1234"  及时改变的        resultCells : null,        gotoPage: function (page, async) {            // TODO            // 离线没有load了 内容都已经生成好了            //this.$container.__load__({            // 生成导出时候的初始html            this.$container.html(FR.WE.getHtml(this.idx));            this.initLGPComponent();            this.writePane.curLGP = this;            // alex:设置this.$container为当前的formPane.ContentContainer            this.writePane.$currentContentContainer = this.$container;            this.writePane.isLoadingPage = -1;            delete this.loaded;            //fire formPane的afterload事件,并把this作为参数传过去            this.writePane.fireEvent(FR.Events.AFTERLOAD, this);            /*             * alex:应该在afterload之后再选中单元格             * 因为客户可能会在afterload事件上添加监听,监听当cellselect时要做些事情             */            //重新加载后，还是清空原先的好点，否则不仅浪费操作还容易出问题            this.currentTDCell = null;            this.editorEl = null;            this.cellEditing = null;            this._selectFirstTD();            if (FR.isMobileApp() && !FR.isMobileAppNoZoom()) {                $(".sheet-container", this.$container).css({                    width:$(".sheet-container", this.$container).children().width(),                    height:$(".x-table", this.$container).height()                });                //new iScroll(this.$container[0]);                var contentContainer = $('.content-container');                contentContainer.css('position', 'relative');                var $sheetContainer = $(".sheet-container", this.$container);                contentContainer.width($sheetContainer.width());                contentContainer.height($sheetContainer.height());                contentContainer.css('overflow', 'hidden');            } else if (FR.isMobileBrowser() && !FR.isMobileBrowserNoZoom()) {                FR.MobileTools.largeWidth($('.x-table', this.$container).width());            }            // 根据本地存储的数据更新            this.populateByLocalData();        },        populateByLocalData: function() {            // 插入删除行            // 默认就是按操作顺序来的            // "操作序号-行数-插入点-插入类型"            for (var i=0; i<this.insertRowArr.length; i++) {                var arr = this.insertRowArr[i].split('-');                var type = parseInt(arr[3]);                var isSimple = type >= 2;                var isAppend = type % 2 === 0;                var pos = arr[2];                var posCR = FR.cellStr2ColumnRow(pos);                var fixCR = isSimple ? posCR : this.getFixCR(posCR);                var count = parseInt(arr[1]);                if (isAppend) {                    this.appendRowOnStructure(isSimple, fixCR, count, {});                } else {                    this.deleteRowOnStructure(isSimple, fixCR);                    this.deletedRows.push(fixCR.row);                }            }            // 格子值            var cells = this.resultCells;            for (var cr in cells) {                if (typeof cr == 'string' && cr.match(/[A-Z]+[0-9]+/)) {                    var columnRow = FR.cellStr2ColumnRow(cr);                    var value = "";                    if (typeof cells[cr] == 'string' || typeof cells[cr] == 'number') {                        value = cells[cr];                    } else if (cells[cr].value) {                        value = cells[cr].value;                    }                    if (this.getCellValue(columnRow.col, columnRow.row) != value) {                        this.setCellValue(columnRow.col, columnRow.row, value);                    }                }            }        },        makeNotSupportError: function($errorCell) {            var $errorImgHolder = $(".fx", $errorCell).length === 0 ? $errorCell : $("td", $(".fx", $errorCell));            $('.verify-error-img', $errorCell).remove();            if ($('.formula-error-img', $errorCell).length === 0) {                $('<img border="0"/>').addClass('verify-error-img')                    .appendTo($errorImgHolder).attr('title', FR.i18nText('Offline-Contain_Unsupport_Function'))                    .attr('src', FR.servletURL + '?op=resource&resource=/com/fr/web/images/warning2.png');            }        },        refreshDataOnInit: function() {            var config = FR.WE.getSheetConfig(this.idx) || {};            var cons = FR.WE.constant;            this.colArray = config[cons.COL_ARRAY] || [];            this.rowArray = config[cons.ROW_ARRAY] || [];            this.oriInsRowArr = config[cons.ORI_INS_ROW_ARRAY] || [];            this.deletedRows = config[cons.DELETED_ROWS] || [];            this.insertRowArr = [];            this.dependOnWho = config["dependOnWho"] || {};            this.whoDependOn = config["whoDependOn"] || {};            this.baseCells = config["baseCells"]     || {};            this.resultCells = config["resultCells"] || {};            this.verify = config["verify"]           || [];        },        refreshDataByLocal: function() {            var data = FR.WE.localData.getSheetData(this.idx) || {};            var localCon = FR.WE.localData.constant;            if (data[localCon.COL_ARRAY]) {                this.colArray = data[localCon.COL_ARRAY];            }            if (data[localCon.ROW_ARRAY]) {                this.rowArray = data[localCon.ROW_ARRAY];            }            if (data[localCon.INS_ROW_ARRAY]) {                this.insertRowArr = data[localCon.INS_ROW_ARRAY];            }            this.resultCells = $.extend(this.resultCells, data[localCon.RESULT_CELLS]);            // 初始化插入删除行操作计数器            if (data[localCon.ROW_OPERATE_COUNTER]) {                this.rowOperateCounter = data[localCon.ROW_OPERATE_COUNTER];            } else {                this.rowOperateCounter = this.insertRowArr.length;                FR.WE.storeRowOperateCounter(this.insertRowArr.length, this.idx);            }        },        getWriteShortCuts: function () {            return FR.WE.config.writeShortCuts;        },        /*         * 单元格值改变后         */        fireCellValueChange: function (tdCell, cv, fm, addHistory) {            if (tdCell == null) {                return;            }            var $tdCell = $(tdCell);            FR.setCellValue($tdCell, cv);            var cal = false;            if (fm == null) {                if ($tdCell.attr('fm') != null) {                    cal = true;                }                $tdCell.removeAttr("fm");            } else {                $tdCell.attr('fm', fm);                cal = true;            }            $(tdCell).addClass('dirty');            // 格子值改变了 需要记录到本地            var cr = FR.id2ColumnRow($tdCell.attr("id"));            this.resultCells[FR.columnRow2CellStr(cr)] = cv;            FR.WE.storeResultCells(this.resultCells, this.idx);            this.dirtyCell.push(tdCell);            if (cal || $tdCell.attr("frs") != null) {                this.writePane.writeDirtyAndRemoteCal(this.idx, FR.id2ColumnRowStr($tdCell.attr("id")), cv, fm);            }            // richer:通知单元格改变,用于联动            this.fireEvent(FR.Events.CELLVALUECHANGE, $(tdCell), cv);            if (addHistory !== false) {                this.writePane.addHistory();            }        },        /*         * 离线形态处理         */        present: function ($tdCell, cv) {            var cr = FR.id2ColumnRow($tdCell.attr('id'));            var oriCE = this.getCEFrom(cr);            var formula = oriCE.presentFormula;            var relatedCRs = FR.WE.getRelatedColumnRow(formula);            var cellsForCal = this.collectRelatedCellValues(cr, relatedCRs);            var calConfig = {                lgp: this,                relatedCells: cellsForCal,                parameters: $.extend({}, self.parameters, {                    $$$: cv                })            }            var result = new FR.CAL(calConfig).eval(formula);            return result;        },        collectRelatedCellValues: function(cr, relatedCRs) {            var oriCE = this.getCEFrom(cr);            var oriCr = FR.cellStr2ColumnRow(oriCE.cr);            var row_offset = this.getRowOffset(cr, oriCr);            var col_offset = cr.col - this.colArray.indexOf(oriCr.col);            var cellsForCal = {};            for (var i=0; i<relatedCRs.length; i++) {                var relatedValues = this.getExpandCellValues(relatedCRs[i]);                // 如果是关联的取对应层次的值                if (this.isInCalLayer(oriCE, relatedCRs[i])) {                    cellsForCal[relatedCRs[i]] = relatedValues[row_offset][col_offset];                }                // 如果没有父子关系 取整个值                else {                    if (relatedValues[0].length === 1) {                        cellsForCal[relatedCRs[i]] = $.map(relatedValues, function(rv) {                             return rv[0];                        });                    } else if (relatedValues.length === 1) {                        cellsForCal[relatedCRs[i]] = relatedValues[0];                    } else {                        cellsForCal[relatedCRs[i]] = relatedValues;                    }                }            }            return cellsForCal;        },        /**         * 重计算         * 重新计算关联公式格子         * 用于插入删除行         * 不能计算所有格子 如原来公式=range(2)后来进行了插入行         * 或者通过上面控件修改了格子值 重计算时候得保持         */        recalculate: function() {            // 把依赖于其他格子的格子都找出来            var ceArr = {};            for (var cell in this.dependOnWho) {                if (!ceArr[cell]) {                    ceArr[cell] = {                        ce_from: this.getCEFrom(cell),                        calculated: false,                        idx: this.idx                    };                }            }            try {                for (var cr in ceArr) {                    this.writePane.calculateCertainCell(this.idx, ceArr, cr);                }            } catch(e) {            } finally {                for (cr in ceArr) {                    delete ceArr[cr].calculated;                    delete ceArr[cr].isCalculating;                }            }        },        appendRowOnStructure: function(isSimple, fixCR, fixCount, tmpCells) {            var $table = this.$table;            var colCount = this.table_width;            var fixTd = $(this.getTDCell(fixCR.col, fixCR.row));            var fixTr = fixTd.parent();            var fixId = fixTd.attr('id');       // A1-0-0            var fixSpan = parseInt(fixTd.attr('rowspan')) || 1;            var td_suffix = fixId.substring(fixId.indexOf('-'), fixId.length); // td的后缀  -0-0            for (var i=0; i<fixCount; i++) {                var startIdx = fixCR.row + (i + 1) * fixSpan;                var $tmpTable = $('<table/>');                var $tmpTr;                if (!isSimple) { //按钮插入行                    // 一次插入几行由原始格子是否是合并格子决定                    for (var spanIdx=0; spanIdx<fixSpan; spanIdx++) {                        // 复制原tr                        var tr = $('#'+FR.getOffsetTRID(fixTr, spanIdx), $table).clone(true);                        var curRowIdx = parseInt(tr.attr('id').split('-')[1]);                        FR.changeTRId(tr, (i + 1) * fixSpan);                        tr.attr('tridx', parseInt(tr.attr('tridx')) + fixSpan);                        // 左侧的td要设置不管是否是可扩展的 都设置rowspan加1                        // 右侧的需要重置id widget editor等属性                        for (var j=0; j<colCount; j++) {                            var curCR = {col:j, row: curRowIdx};                            var curStr = FR.columnRow2CellStr(curCR);                            var td = $('td#'+curStr+td_suffix, tr);                            if (j < fixCR.col && (td.length === 0 || parseInt(td.attr('rowspan')) > 1)) {                                changeUpperTdRowSpan(fixCR, curCR);                                // 改变上面的rowspan了 那么久不应该添加这个td                                td.remove();                            } else {                                if (!td || td.length === 0) {                                    continue;                                }                                FR.changeTDId(td, fixSpan);                                FR.changeTDWidget(td);                                tmpCells[FR.id2ColumnRowStr(td.attr('id'))] = FR.changeTDValue(curCR, td);                            }                        }                        tr.appendTo($tmpTable);                    }                }                else {  //工具栏增加记录                    var tr = $('#'+FR.getOffsetTRID(fixTr, fixSpan-1), $table).clone(true);                    var curRowIdx = parseInt(tr.attr('id').split('-')[1]);                    FR.changeTRId(tr, 1);                    tr.attr('tridx', parseInt(tr.attr('tridx')) + 1);                    for (var j=0; j<colCount; j++) {                        var curCR = {col:j, row: curRowIdx};                        var curStr = FR.columnRow2CellStr(curCR);                        var td = $('td#'+curStr+td_suffix, tr);                        if (j < fixCR.col && (td.length === 0 || parseInt(td.attr('rowspan')) > 1)) {                            changeUpperTdRowSpan(fixCR, curCR);                            td.remove();                        } else {                            if (!td || td.length === 0) {                                continue;                            }                            FR.changeTDId(td, parseInt(td.attr('rowspan') || 1));                            td.removeAttr('rowspan');                            FR.changeTDWidget(td);                            tmpCells[FR.id2ColumnRowStr(td.attr('id'))] = FR.changeTDValue(curCR, td);                        }                    }                    tr.appendTo($tmpTable);                }                $tmpTr = $('tr[tridx]', $tmpTable);                var mergeCells = [];                this.appendRow(startIdx, $tmpTr, mergeCells);            }            function changeUpperTdRowSpan(fixCR, curCR) {                for (var k=fixCR.row; k>=0; k--) {                    var curStr = FR.columnRow2CellStr({col: curCR.col, row: k});                    var newtd = $('td#'+curStr+td_suffix, $table);                    if (newtd.length > 0) {                        FR.changeTDRowSpan(newtd, 1);                        break;                    }                }            }        },        deleteRowOnStructure: function(isSimple, fixCR) {            var $table = this.$table;            var colCount = this.table_width;            var fixTd = $(this.getTDCell(fixCR.col, fixCR.row));            var fixTr = fixTd.parent();            var fixId = fixTd.attr('id');       // A1-0-0            var fixSpan = fixTd.attr('rowspan') || 1;            var td_suffix = fixId.substring(fixId.indexOf('-'), fixId.length); // td的后缀  -0-0            var startIdx = fixCR.row;            for (var spanIdx=0; spanIdx<fixSpan; spanIdx++) {                var tr = $('#'+FR.getOffsetTRID(fixTr, spanIdx), $table);                var curRowIdx = parseInt(tr.attr('id').split('-')[1]);                // 下一行也可能是删除了的                var nextOffset = 1;                var nextRowIdx = curRowIdx + nextOffset;                var nextTr = $('#'+FR.getOffsetTRID(fixTr, spanIdx+nextOffset), $table);                var trCnt = 0;                while(nextTr.length > 0 && !nextTr.isVisible()) {                    trCnt ++;                    nextTr = $('#'+FR.getOffsetTRID(fixTr, spanIdx+nextOffset+trCnt), $table);                }                for (var j=0; j<colCount; j++) {                    var curCR = {col:j, row: curRowIdx};                    var curStr = FR.columnRow2CellStr(curCR);                    var td = $('td#'+curStr+td_suffix, tr);                    if (j < fixCR.col) {                        if (td.length === 0) {                            //tr里没有 那到上面合并格子找                            var found = false;                            for (var k=fixCR.row; k>=0; k--) {                                curCR.row = k;                                curStr = FR.columnRow2CellStr(curCR);                                td = $('td#'+curStr+td_suffix, $table);                                if (td.length > 0 && td.attr('rowspan') > 1) {                                    FR.changeTDRowSpan(td, -1);                                    found = true;                                    break;                                }                            }                            if (found) {                                continue;                            }                        }                    }                    // 如果即将隐藏的这一行某个td的rowSpan>1那么                    // 需要在他下一行添加一个rowSpan为rowSpan-1的td                    if (parseInt(td.attr('rowSpan')) > 1) {                        var nextTd = td.clone(true);                        var nextCR = {col:j, row:nextRowIdx};                        nextTd.attr('id', FR.columnRow2CellStr(nextCR) + td_suffix);                        nextTd.attr('rowSpan', parseInt(td.attr('rowSpan'))-1);                        if (j === 0) {                            nextTr.prepend(nextTd);                        } else {                            // 万一前一列的也没有呢                            for (var kk=j-1; kk>=0; kk--) {                                var pretd = $('td#'+FR.columnRow2CellStr({col:kk, row:nextRowIdx})+td_suffix, tr);                                if (pretd.length > 0) {                                    pretd.after(nextTd);                                    break;                                }                            }                        }                        td.removeAttr('rowSpan');                    }                }            }            var mergeCells = [];            this.deleteRow(startIdx, fixSpan, mergeCells);        },        appendRowOnData: function(isSimple, fixCR, fixCount, fixSpan, locStr, tmpCells) {            var self = this;            // 更新colArray rowArray            var startIdx = fixCR.row + fixSpan;            for (var jj=0; jj<fixCount; jj++) {                for (var ii=0; ii<fixSpan; ii++) {                    var oriRow = this.rowArray[fixCR.row + ii];                    this.rowArray.splice(startIdx + ii, 0, oriRow);                }            }            FR.WE.storeRowArray(this.rowArray, this.idx);            // 更新deletedRows            for (var kk=0; kk<this.deletedRows.length; kk++) {                if (this.deletedRows[kk] > fixCR.row) {                    this.deletedRows[kk] = this.deletedRows[kk] + 1;                }            }            // 更新resultCells            var offset = isSimple ? fixCount : fixCount * fixSpan;            for (var crStr in this.resultCells) {                var cr = FR.cellStr2ColumnRow(crStr);                tmpCells[getChangedDepStr(crStr)] = this.resultCells[crStr];            }            this.resultCells = tmpCells;            FR.WE.storeResultCells(tmpCells, this.idx);            // 更新dependence            // 增加新加的格子关系、            // 同时要把后面的都修改掉            this.whoDependOn = changeDependence(this.whoDependOn);            this.dependOnWho = changeDependence(this.dependOnWho);            for (var i=0; i<fixCount; i++) {                if (!isSimple) {                    for (var j=0; j<fixSpan; j++) {                        addDependence((i+1) * fixSpan + j);                    }                } else {                    addDependence((i+1) * fixSpan);                }            }            function changeDependence(depend) {                var tmpDependOn = {};                for (var dCRStr in depend) {                    var dCR = FR.cellStr2ColumnRow(dCRStr);                    tmpDependOn[getChangedDepStr(dCRStr)] = getChangedDepArr(depend[dCRStr]);                }                return tmpDependOn;            }            function getChangedDepArr(arr) {                var tmpArr = [];                for (var m=0; m<arr.length; m++) {                    var recArr = arr[m].split('-');                    tmpArr.push(getChangedDepStr(recArr[0]) + '-' + recArr[1])                }                return tmpArr;            }            function getChangedDepStr(crStr) {                var cr = FR.cellStr2ColumnRow(crStr);                if (cr.row < fixCR.row + fixSpan) {                    return crStr;                } else {                    return FR.columnRow2CellStr({col:cr.col, row: cr.row+offset});                }            }            function addDependence(rowOffset) {                var row = fixCR.row + rowOffset;                for (var k=0; k<self.table_width; k++) {                    var oriCrStr = FR.columnRow2CellStr({col:k, row: fixCR.row});                    var newCrStr = FR.columnRow2CellStr({col:k, row: row});                    addEachDependence(self.whoDependOn, oriCrStr, newCrStr, rowOffset);                    addEachDependence(self.dependOnWho, oriCrStr, newCrStr, rowOffset);                }            }            function addEachDependence(depend, oriCrStr, newCrStr, rowOffset) {                if (depend[oriCrStr]) {                    var depArr = depend[oriCrStr];                    var newDepArr = [];                    for (var p=0; p<depArr.length; p++) {                        var depCRArray = depArr[p].split('-'); // 'A1-0'                        var depCRStr = depCRArray[0];                        var sheetIdx = depCRArray[1];                        var depCR = FR.cellStr2ColumnRow(depCRStr);                        if (self.isInFamily(oriCrStr, depCRStr) &&                                    self.rowArray[depCR.row + rowOffset] == self.rowArray[depCR.row]) {                            var newDepCRStr = FR.columnRow2CellStr({col:depCR.col, row:depCR.row+rowOffset});                            newDepArr.push(newDepCRStr + "-" + sheetIdx);                        } else {                            newDepArr.push(depArr[p]);                        }                    }                    depend[newCrStr] = newDepArr;                }            }            // 更新insertRowArr            // "操作序号-行数-插入点按钮单元格-插入类型"            var record = this.rowOperateCounter + "-" + fixCount + "-" + locStr + "-" + (isSimple ? "2" : "0");            this.insertRowArr.push(record);            FR.WE.storeInsertRowArr(this.insertRowArr, this.idx);            this.updateRowOperateCounter();        },        deleteRowOnData: function(isSimple, fixCR, locStr) {            this.deletedRows.push(fixCR.row);            var record = this.rowOperateCounter + "-" + 1 + "-" + locStr + "-" + (isSimple ? "3" : "1");            this.insertRowArr.push(record);            FR.WE.storeInsertRowArr(this.insertRowArr, this.idx);            this.updateRowOperateCounter();        },        updateRowOperateCounter: function() {            this.rowOperateCounter ++;            FR.WE.storeRowOperateCounter(this.rowOperateCounter, this.idx);        },        // TODO 下面加些WLGP运算的东西        /**         * shoc 根据扩展后的行列获取原始格子         * cr: "A1"    or   {col:0,row:0}         */        getCEFrom: function(cr) {            if (typeof cr == 'string') {                cr = FR.cellStr2ColumnRow(cr);            }            if (cr == null || cr.col == null || cr.row == null) {                return null;            }            var oriCol = this.colArray[cr.col];            var oriRow = this.rowArray[cr.row];            var oriCR = FR.columnRow2CellStr({col:oriCol, row:oriRow});            return this.baseCells[oriCR];        },        getCE: function(cr) {            if (cr == null) {                return null;            }            if (cr.col != null && cr.row != null) {                cr = FR.columnRow2CellStr(cr);            }            return this.baseCells[cr];        },        getCEExpandDir: function(cell) {            if (cell.direction != FR.WE.constant.DIRECTION_NONE) {                return cell.direction;            }            var left = cell;            while (left != null) {                var leftCR = FR.cellStr2ColumnRow(left.cr);                left = cell.leftDefault ? this.getCE(FR.columnRow2CellStr({col: leftCR.col-1, row: leftCR.row})) : this.getCE(left.left);                if (left.direction != FR.WE.constant.DIRECTION_NONE) {                    return left.direction;                }            }            var up = cell;            while (up != null) {                var upCR = FR.cellStr2ColumnRow(up.cr);                up = cell.upDefault ? this.getCE(FR.columnRow2CellStr({col: upCR.col-1, row: upCR.row})) : this.getCE(up.left);                if (up.direction != FR.WE.constant.DIRECTION_NONE) {                    return up.direction;                }            }        },        getFixCR: function(location) {            var btnTD = $(this.getTDCell(location.col, location.row));            var fixCell = btnTD.attr('fixCell'); // 目标格子'A1'            // 偏移量后台不太好整 放这里算            var offset = location.row - this.rowArray[location.row];            var fixCR = FR.cellStr2ColumnRow(fixCell);            fixCR.row += offset;            return fixCR;        },        isInCalLayer: function(tar, related) {            if (tar == null || related == null) {                return false;            }            if (typeof tar == 'string') {                tar = this.getCEFrom(tar);            }            if (typeof related == 'string') {                related = this.getCEFrom(related);            }            if (!this.isInFamily(related, tar)) {                return false;            }            var tarCR = FR.cellStr2ColumnRow(tar.cr);            var relCR = FR.cellStr2ColumnRow(related.cr);            if (this.isDefaultUpAncestor(related, tar)                && this.getCEExpandDir(related) == FR.WE.constant.DIRECTION_TOP_TO_BOTTOM) {                return false;            }            if (this.isLeftAncestor(related, tar)                && this.getCEExpandDir(related) == FR.WE.constant.DIRECTION_LEFT_TO_RIGHT) {                return false;            }            return true;        },        isInFamily: function(ce1, ce2) {            if (ce1 == null || ce2 == null) {                return false;            }            var ceA = ce1, ceB = ce2;            if (typeof ce1 == 'string') {                ceA = this.getCEFrom(ce1);            }            if (typeof ce2 == 'string') {                ceB = this.getCEFrom(ce2);            }            return this.AisAncestorOfB(ceA, ceB) || this.AisAncestorOfB(ceB, ceA);        },        /**         * 判断cellA是否是cellB的父辈         * @param ceA : BaseCells Object         * @param ceB         * @return {boolean}         * @private         */        AisAncestorOfB: function(ceA, ceB, types) {            if (ceA == null || ceB == null) {                return false;            }            var ceBcr = FR.cellStr2ColumnRow(ceB.cr);            // 不能通过default一直这么找下去            // 都是default的话 必须在同一行或同一列            // 加这个types参数收集整个路径的类型            // 左default的就加个"0" 左自定义加个"1" 上default2 上自定义3            if (types == null) {                types = "";            }            var leftB;            if (ceB.leftDefault && ceA.direction != FR.WE.constant.DIRECTION_LEFT_TO_RIGHT) {                if (ceBcr.col > 0) {                    leftB = FR.columnRow2CellStr({col: ceBcr.col-1, row: ceBcr.row});                }            } else if (typeof ceB.left == 'string') {                leftB = ceB.left;            }            if (leftB != null                && (ceA.cr == leftB || this.AisAncestorOfB(ceA, this.getCE(leftB)))                && rightTypes(true)) {                return true;            }            var upB;            if (ceB.upDefault && ceA.direction != FR.WE.constant.DIRECTION_TOP_TO_BOTTOM) {                if (ceBcr.row > 0) {                    upB = FR.columnRow2CellStr({col: ceBcr.col, row: ceBcr.row-1});                }            } else if (typeof ceB.up == 'string') {                upB = ceB.up;            }            if (upB != null                && (ceA.cr == upB || this.AisAncestorOfB(ceA, this.getCE(upB)))                && rightTypes(false)) {                return true;            }            function rightTypes(isLeft) {                if (types.length > types.replace('0', '').length                    && types.length > types.replace('2', '').length) {                    return false;                }                if (isLeft) {                    if (types.replace('0', '').length === 0                        && FR.cellStr2ColumnRow(ceB.cr).row != FR.cellStr2ColumnRow(ceA.cr).row) {                        return false;                    }                } else {                    if (types.replace('2', '').length === 0                        && FR.cellStr2ColumnRow(ceB.cr).col != FR.cellStr2ColumnRow(ceA.cr).col) {                        return false;                    }                }                return true;            }            return false;        },        ABOfSameAncestor: function(ceA, ceB) {        },        isLeftAncestor: function(ceA, ceB) {            if (ceA == null || ceB == null) {                return false;            }            var leftB;            if (typeof ceB.left == 'string') {                leftB = ceB.left;            }            return leftB != null && (ceA.cr == leftB || this.isLeftAncestor(ceA, this.getCE(leftB)));        },        isDefaultLeftAncestor: function(ceA, ceB) {            if (ceA == null || ceB == null) {                return false;            }            var ceBcr = FR.cellStr2ColumnRow(ceB.cr);            var leftB;            if (ceB.leftDefault && ceA.direction != FR.WE.constant.DIRECTION_LEFT_TO_RIGHT && ceBcr.col > 0) {                leftB = FR.columnRow2CellStr({col: ceBcr.col-1, row: ceBcr.row});            }            return leftB != null && (ceA.cr == leftB || this.isDefaultLeftAncestor(ceA, this.getCE(leftB)));        },        isUpAncestor: function(ceA, ceB) {            if (ceA == null || ceB == null) {                return false;            }            var upB;            if (typeof ceB.up == 'string') {                upB = ceB.up;            }            return upB != null && (ceA.cr == upB || this.isUpAncestor(ceA, this.getCE(upB)));        },        isDefaultUpAncestor: function(ceA, ceB) {            if (ceA == null || ceB == null) {                return false;            }            var ceBcr = FR.cellStr2ColumnRow(ceB.cr);            var upB;            if (ceB.upDefault && ceA.direction != FR.WE.constant.DIRECTION_TOP_TO_BOTTOM && ceBcr.row > 0) {                upB = FR.columnRow2CellStr({col: ceBcr.col, row: ceBcr.row-1});            }            return upB != null && (ceA.cr == upB || this.isDefaultUpAncestor(ceA, this.getCE(upB)));        },        /**         * 原始格子cr扩展出的所有格子值         * 横向扩展 纵向扩展 双向扩展  所以是二维数组         * 还得考虑被删除格子的情况         * @param cr         */        getExpandCellValues: function(cr, in1DArr) {            if (cr == null) {                return null;            }            if (typeof cr == 'string') {                cr = FR.cellStr2ColumnRow(cr);            }            if (cr == null || cr.col == null || cr.row == null) {                return null;            }            var colStart = this.colArray.indexOf(cr.col);            var colEnd = this.colArray.lastIndexOf(cr.col);            var rowStart = this.rowArray.indexOf(cr.row);            var rowEnd = this.rowArray.lastIndexOf(cr.row);            var values = [];            for (var row=rowStart; row<=rowEnd; row++) {                if (this.isDeletedRow(row)) {                    continue;                }                var idx = row - rowStart;                if (in1DArr === true) {                    for (var col=colStart; col<=colEnd; col++) {                        values.push(this.getCellValue(col, row));                    }                } else {                    var t = [];                    for (var col=colStart; col<=colEnd; col++) {                        t.push(this.getCellValue(col, row));                    }                    values.push(t);                }            }            return values;        },        isDeletedRow: function(row) {            return this.deletedRows.indexOf(row) !== -1;        },        /**         * cr: {col:0, row:0}         * @param cr         */        getExpandValueCount: function(cr) {            return (this.colArray.lastIndexOf(cr.col) - this.colArray.indexOf(cr.col) + 1)                * (this.rowArray.lastIndexOf(cr.row) - this.rowArray.indexOf(cr.row) + 1);        },        getExpandColCount: function(cr) {            return this.colArray.lastIndexOf(cr.col) - this.colArray.indexOf(cr.col) + 1;        },        getExpandRowCount: function(cr) {            return this.rowArray.lastIndexOf(cr.row) - this.rowArray.indexOf(cr.row) + 1;        },        getRowOffset: function(cr, oriCr) {            var start = this.rowArray.indexOf(oriCr.row);            var row_offset = cr.row - start;            // 得考虑删除行的情况            for (var i=0; i<this.deletedRows.length; i++) {                if (this.deletedRows[i] >= start && this.deletedRows[i] < cr.row) {                    row_offset --;                }            }            return row_offset;        },        getExpandColumnRowStr: function(cr, index) {            if (typeof cr == 'string') {                cr = FR.cellStr2ColumnRow(cr);            }            if (cr == null || cr.col == null || cr.row == null) {                return null;            }            var colCnt = this.getExpandColCount(cr);            var rowCnt = this.getExpandRowCount(cr);            var resultCol = this.colArray.indexOf(cr.col) + (index % colCnt);            var resultRow = this.rowArray.indexOf(cr.row) + Math.min(parseInt(index / colCnt), rowCnt);            return FR.columnRow2CellStr({col: resultCol, row: resultRow});        },        /**         * 通过一组ColumnRow 获取值阵列用来逐行校验         * 要注意双向扩展的情况         * 返回[[A1值,B1值,C1值]]         * @param crs         */        getCellValueGroup: function(arr) {            if (arr == null || !$.isArray(arr)) {                return [];            }            var i, crs = [];            // 传入的是个数组 不能改了人家东西啊!            for (i=0; i<arr.length; i++) {                if (typeof arr[i] == 'string') {                    crs[i] = FR.cellStr2ColumnRow(arr[i]);                } else {                    crs[i] = arr[i];                }            }            // 要找基准格子 基准格子要求扩展的值要最多            // 扩展数目相同的话优先取父格            var baseCR = crs[0];            var baseIdx = 0;            var baseCnt = this.getExpandValueCount(baseCR);            var cols = this.colArray, rows = this.rowArray;            var counts = [];            for (i=1; i<crs.length; i++) {                var curCnt = counts[i] = this.getExpandValueCount(crs[i]);                if ((baseCnt < curCnt) ||                    (baseCnt == curCnt && this.AisAncestorOfB(this.getCE(baseCR), this.getCE(crs[i])))) {                    baseCR = crs[i];                    baseIdx = i;                    baseCnt = curCnt;                }            }            var result = [];            var container = [];            for (i=0; i<crs.length; i++) {                if (i == baseIdx) {                    container[i] = this.getExpandCellValues(baseCR, true);                    continue;                }                if (counts[i] == baseCnt) {                    container[i] = this.getExpandCellValues(crs[i], true);                } else if (counts[i] === 1) {                    container[i] = FR.WE.makeArray(this.getExpandCellValues(crs[i], true)[0], baseCnt);                } else {                    container[i] = this.getExpandCellValues(crs[i], true);                }            }            for (i=0; i<baseCnt; i++) {                result[i] = [];                for (var j=0; j<crs.length; j++) {                    result[i][j] = container[j][i];                }            }            return result;        }    }}())$.extend(FR, {    changeTDValue: function(curCR, td) {        var ce = _g().curLGP.getCEFrom(curCR);        if (!ce) {            return;        }        var cons = FR.WE.constant;        var ins = ce[cons.INSERT_POLICY_TAG];        var value = td.val() || td.text();        if (ins != cons.INSERT_POLICY_COPY) {            if (ins == null || ins == cons.INSERT_POLICY_NULL) {                value = "";            } else if (ins == cons.INSERT_POLICY_DEFAULT) {                value = ce[cons.INSERT_POLICY_DEFAULT_VALUE] || '';            }            FR.setCellValue(td, value);            td.text(value);        }        return value;    },    changeTRId: function(tr, offset) {        tr.attr('id', this.getOffsetTRID(tr, offset));    },    getOffsetTRID: function(tr, offset) {        var id = tr.attr('id');        if (!id) {            return;        }        var arr = id.split("-");        arr[1] = offset + parseInt(arr[1]);        return arr.join("-");    },    changeTDId: function(td, offset) {        var id = td.attr("id");        if (!id) {            return;        }        var cr = FR.id2ColumnRow(id);        cr.row += offset;        td.attr('id', FR.columnRow2CellStr(cr) + "-" + _g().curLGP.idx + "-" + _g().curLGP.tableID);    },    changeTDRowSpan: function(td, offset) {        var span = parseInt(td.attr('rowspan')) || 1;        span += parseInt(offset);        td.attr('rowspan', span);    },    changeTDWidget: function(td) {        var id = td.attr("id");        if (!id) {            return;        }        var cr = FR.id2ColumnRow(id);        var widget = td.attr('widget'), editor = td.attr('editor');        if (widget) {            td.attr("widget", _g().curLGP._replaceEditorStr(widget, cr));            td.empty();        } else if (editor) {            td.attr('editor', _g().curLGP._replaceEditorStr(editor, cr));        }    }});if (window.FR == null) {    window.FR = {};}if (FR.WE == null) {    FR.WE = {};}$.extend(FR.WE, {    /**     * FR.WE.config的结构：     * {     *      reportlet:     *      requertURL:     *      lgps: [     *           {     *              baseCells:{}     *           }     *      ]     * }     * @return     */    getConfig: function() {        return this.config;    },    // 把这东西赋值给lgps会导致这个object跟着变    // 这时候转化成字符串再弄成新的object赋值    getConfigStr: function() {        return FR.jsonEncode(this.config);    },    getSheetConfig : function(reportIdx) {        var config = FR.jsonDecode(this.getConfigStr());        var lgps = config["lgps"];        return lgps[reportIdx];    },    getHtml: function(reportIdx) {        var lgps = this.config["lgps"];        var curConfig = lgps[reportIdx];        return curConfig["html"];    },    getReportName: function() {        return this.getConfig()["reportlet"];    },    /**     * shoc:读写本地数据     * 本地数据结构：     * [     *  sheet1{     *      cells {}     *      colArr []     *      rowArr []     *      insRow []     *      delRow []     *      rowOperateCounter     *      }     * ]     */    localData: function() {        var emptyRecord = "[]";        // ie的userData属性名不能以0开头 统一加个前缀        // 还不能有'/'        // 还不支持中文        var reportPath = FR.WE.config["reportlet"];        reportPath.replace(/\//g, '');        var name = FR.cjkEncode("fr" + reportPath), ld;        // history中存储的个数是0到limit个 当前的总是放在最后 curPos为0表示当前的 撤销一步变为-1        var limit = 5, curPos = 0, history = [emptyRecord];        // 一次编辑可能触发多个保存 用时间间隔控制        var lastTime = new Date().getTime();        // IE8以下使用userData,兼容 IE5~IE8,IE9&IE9+不再支持userData        // IE9+支持localStorage,但是只有当页面部署在服务器上才能使用localStorage        var be = document.documentElement;        var dbName = "frData";        var isIE = /(msie\s|trident.*rv:)([\w.]+)/.exec(navigator.userAgent.toLowerCase()) != null;        var version = $.browser.version;        var isIEWithUserData = isIE && parseInt(version) < 9;        if (isIEWithUserData) {            var box = document.body || document.getElementsByTagName("head")[0] || document.documentElement;            be = document.createElement('input');            be.type = "hidden";            be.addBehavior ("#default#userData");            box.appendChild(be);        }        return {            getLocalData: function() {                if (ld) {                    return ld;                } else {                    var s;                    if (isIEWithUserData) {                        be.load(dbName);                        s = be.getAttribute(name);                    } else if (window.localStorage) {                        s = window.localStorage.getItem(name);                    } else {                        FR.Msg.toast("Browser Not Support!");                    }                    if (s == null) {                        ld = [{                            cells: {}                        }];                    } else {                        ld = FR.jsonDecode(s);                    }                    if (!$.isArray(ld)) {                        var arr = [];                        arr.push(ld);                        ld = arr;                    }                    for (var i=0; i<FR.WE.config.lgps.length; i++) {                        if (!ld[i]) {                            ld[i] = {                                cells: {}                            }                        }                    }                    return ld;                }            },            setLocalData: function(data) {                ld = data;                var value = FR.jsonEncode(data);                this.setStrQuietly(value);            },            clearLocalData: function() {                if (isIEWithUserData) {                    be.load(dbName);                    be.removeAttribute(name);                    be.save(dbName);                } else if (window.localStorage) {                    window.localStorage.removeItem(name);                } else {                    FR.Msg.toast("Browser Not Support!");                }                ld = null;                this.addHistory(emptyRecord);            },            undo: function() {                this.moveHistory(-1);            },            redo: function() {                this.moveHistory(1);            },            // 用于set和clear            addHistory: function(value) {                var str = value == null ? FR.jsonEncode(ld) : value + "";                if (new Date().getTime() - lastTime > 100                    && str != history[history.length - 1 + curPos]) {                    // 必须把curPos置为初始状态                    // 如果是在history中间 其后面的数据都要抹掉                    // 当前位置为history.length - 1 + curPos 要从其后一位开始删除                    if (curPos < 0) {                        history.splice(history.length + curPos, -curPos);                    } else {                        if (history.length == limit) {                            history.splice(0, 1);                        }                    }                    history.push(str);                    curPos = 0;                    lastTime = new Date().getTime();                }            },            // 用于undo和redo            moveHistory: function(dir) {                var t = history.length - 1 + curPos + dir;                this.setStrQuietly(history[t]);                ld = FR.jsonDecode(history[t]);                curPos += dir;            },            // 用编码好的str设置data 不记录            // history中记录编码后的 Undo的时候不用再编码了            setStrQuietly: function(value) {                if (isIEWithUserData) {                    be.setAttribute(name, value);                    be.save(dbName);                } else if (window.localStorage) {                    window.localStorage.setItem(name, value);                } else {                    FR.Msg.toast("Browser Not Support!");                }            },            getSheetData: function(sheetIdx) {                var data = FR.WE.localData.getLocalData();                return sheetIdx == null ? data[0] : data[sheetIdx];            },            // 是否能向左移动            hasBeforeHistory: function() {                return -curPos < history.length - 1;            },            // 是否能向右移动            hasAfterHistory: function() {                return -curPos > 0 && history.length > 0;            },            constant: {                RESULT_CELLS: "cells",                ROW_ARRAY: "rowArr",                COL_ARRAY: "colArr",                INS_ROW_ARRAY: "insRow",                DEL_ROW_ARRAY: "delRow",                ROW_OPERATE_COUNTER: "rowOperateCounter",                PROCESS_NOTE: "processNote",                PARAMETERS: "parameters"            }        }    }(),    storeSomeThing: function(type, value, sheetIndex) {        if (type == null || value == null) {            return;        }        if (sheetIndex == null) {            sheetIndex = 0;        }        var data = FR.WE.localData.getLocalData();        if (data == null || !$.isArray(data)) {            data = [];        }        if (data[sheetIndex] == null) {            data[sheetIndex] = {};        }        var con = FR.WE.localData.constant;        for (var t in con) {            if (type == con[t]) {                data[sheetIndex][type] = value;                FR.WE.localData.setLocalData(data);                break;            }        }    },    storeResultCells: function(cells, idx) {        this.storeSomeThing(FR.WE.localData.constant.RESULT_CELLS, cells, idx);    },    storeRowArray: function(rowArr, idx) {        this.storeSomeThing(FR.WE.localData.constant.ROW_ARRAY, rowArr, idx);    },    storeColArray: function(colArr, idx) {        this.storeSomeThing(FR.WE.localData.constant.COL_ARRAY, colArr, idx);    },    storeInsertRowArr: function(insRowArr, idx) {        this.storeSomeThing(FR.WE.localData.constant.INS_ROW_ARRAY, insRowArr, idx);    },    storeRowOperateCounter: function(count, idx) {        this.storeSomeThing(FR.WE.localData.constant.ROW_OPERATE_COUNTER, count, idx);    },    storeProcessNote: function(note) {        this.storeSomeThing(FR.WE.localData.constant.PROCESS_NOTE, note);    },    getProcessNote: function() {        var data = this.localData.getSheetData();        return data[FR.WE.localData.constant.PROCESS_NOTE];    },    setParameter: function(name, value) {        var data = this.localData.getSheetData();        var ps = data[FR.WE.localData.constant.PARAMETERS];        if (ps == null) {            ps = {};        }        ps[name] = value;        this.storeSomeThing(FR.WE.localData.constant.PARAMETERS, ps);    },    getParameter: function(name) {        var data = this.localData.getSheetData();        var ps = data[FR.WE.localData.constant.PARAMETERS];        return ps == null ? null : ps[name];    },    getResultCells: function(idx) {        var data = this.localData.getSheetData(idx);        return data[FR.WE.localData.constant.RESULT_CELLS];    },    getRowArray: function(idx) {        var data = this.localData.getSheetData(idx);        return data[FR.WE.localData.constant.ROW_ARRAY];    },    getColArray: function(idx) {        var data = this.localData.getSheetData(idx);        return data[FR.WE.localData.constant.COL_ARRAY];    },    getInsertRowArr: function(dix) {        var data = this.localData.getSheetData(idx);        return data[FR.WE.localData.constant.INS_ROW_ARRAY];    },    getRowOperateCounter: function(idx) {        var data = this.localData.getSheetData(idx);        return data[FR.WE.localData.constant.ROW_OPERATE_COUNTER];    },    constant: {        DIRECTION_TAG: "direction",        DIRECTION_TOP_TO_BOTTOM: 0,        DIRECTION_LEFT_TO_RIGHT: 1,        DIRECTION_NONE: 2,        INSERT_POLICY_TAG: "insertPolicy",        INSERT_POLICY_NULL: "null",        INSERT_POLICY_DEFAULT: "default",        INSERT_POLICY_COPY: "copy",        INSERT_POLICY_DEFAULT_VALUE: "defaultInsertValue",        BASE_CELLS: "baseCells",       	RESULT_CELLS: "resultCells",       	ROW_ARRAY: "rowArray",       	COL_ARRAY: "colArray",        ORI_INS_ROW_ARRAY: "oriInsRowArr",        INS_ROW_ARRAY: "insertRowArr",        DELETED_ROWS: "deletedRows"    }});